package ${cfg.entityPackage};

import jakarta.persistence.*;
import lombok.*;
<#if entity.relations?has_content>
import org.hibernate.annotations.OnDelete;
import org.hibernate.annotations.OnDeleteAction;
</#if>

import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Set;
import java.util.LinkedHashSet;
import java.util.ArrayList;

<#if entity.hasCompositeKey && entity.embeddedId??>
import ${cfg.entityPackage}.${entity.embeddedId.className};
</#if>

/**
 * JPA Entity for table ${entity.tableName}
 * <#if entity.schema??>Schema: ${entity.schema}</#if>
 * <#if entity.catalog??>Catalog: ${entity.catalog}</#if>
 * Automatically generated by EntityGen Maven Plugin
 */
<#-- Generate Lombok excludes for bidirectional relationships -->
<#assign lombokExcludes = [] >
<#list entity.relations as rel>
    <#if rel.bidirectional && (rel.type?string == "ONE_TO_MANY" || rel.type?string == "MANY_TO_MANY" || rel.type?string == "MANY_TO_MANY_DIRECT")>
        <#assign lombokExcludes += [rel.fieldName] >
    </#if>
</#list>
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
<#if lombokExcludes?size &gt; 0>
@ToString(exclude = {<#list lombokExcludes as exclude>"${exclude}"<#if exclude_has_next>, </#if></#list>})
@EqualsAndHashCode(exclude = {<#list lombokExcludes as exclude>"${exclude}"<#if exclude_has_next>, </#if></#list>})
</#if>
@Entity
@Table(
    name = "${entity.tableName}"<#if entity.schema??>,
    schema = "${entity.schema}"</#if><#if entity.uniqueConstraints?has_content>,
    uniqueConstraints = {
<#list entity.uniqueConstraints as uc>
        @UniqueConstraint(name = "${uc.name}", columnNames = {<#list uc.columns as col>"${col}"<#if col_has_next>, </#if></#list>})<#if uc_has_next>,</#if>
</#list>
    }</#if>
)
<#-- Conditional Serializable support -->
<#--
<#assign enableSerialization = config.enableSerialization!true>
<#if enableSerialization>
public class ${entity.className} implements Serializable {

    @Serial
    private static final long serialVersionUID = 1L;
<#else>
-->
public class ${entity.className} {
<#--</#if>-->
<#-- =============================================== -->
<#-- STEP 1: Analyzing Foreign Key Columns -->
<#-- =============================================== -->
<#assign fkColumnNames = {} >
<#list entity.relations as rel>
    <#if rel.joinColumns?? && rel.joinColumns?size &gt; 0>
        <#list rel.joinColumns as jcName>
            <#assign fkColumnNames = fkColumnNames + { (jcName) : true } >
        </#list>
    </#if>
</#list>

<#-- ============================================ -->
<#-- STEP 2: Primary Keys (ID Fields) -->
<#-- ============================================ -->
<#if entity.hasCompositeKey && entity.embeddedId??>
    /**
     * Composite primary key for table ${entity.tableName}
     */
    @EmbeddedId
    @Builder.Default
    <#assign embeddedIdFieldName = entity.embeddedId.className?uncap_first>
    private ${entity.embeddedId.className} ${embeddedIdFieldName} = new ${entity.embeddedId.className}();
</#if><#t>

<#if !entity.hasCompositeKey>
    <#list entity.fields as field>
        <#if field.primaryKey>
    /**
     * Primary key for table ${entity.tableName}
     * <#if field.comment??>Comment: ${field.comment}</#if>
     */
    @Id
    <#if field.autoIncrement>
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    </#if>
    @Column(name = "${field.columnName}")
    private ${field.javaType} ${field.name};
        </#if>
    </#list>
</#if><#t>
<#-- ========================================== -->
<#-- STEP 3: Remaining Fields -->
<#-- ========================================== -->
<#list entity.fields as field>
    <#if !field.primaryKey && !fkColumnNames[field.columnName]?has_content>
    /**
     * Field: ${field.columnName}
     * <#if field.comment??>Comment: ${field.comment}</#if>
     */<#t>
    <#-- Build @Column annotation based on field type -->
    <#assign columnParams = ["name = \"${field.columnName}\""] >
    
    <#-- Add nullable for all types -->
    <#if !field.nullable>
        <#assign columnParams += ["nullable = false"] >
    </#if>
    
    <#-- Add unique for all types -->
    <#if field.unique>
        <#assign columnParams += ["unique = true"] >
    </#if>
    
    <#-- String-specific attributes -->
    <#if field.javaType == "String" && field.length?? && !field.isLob && field.length &gt; 255>
        <#assign columnParams += ["length = ${field.length}"] >
    </#if>
    
    <#-- Numeric-specific attributes (BigDecimal OBAVEZNO, ostali opcionalno) -->
    <#if field.javaType == "BigDecimal" && field.precision??>
        <#assign columnParams += ["precision = ${field.precision}"] >
        <#if field.scale??>
            <#assign columnParams += ["scale = ${field.scale}"] >
        </#if>
    <#elseif (field.javaType == "Double" || field.javaType == "Float") && field.precision?? && field.precision &gt; 15>
        <#assign columnParams += ["precision = ${field.precision}"] >
        <#if field.scale??>
            <#assign columnParams += ["scale = ${field.scale}"] >
        </#if>
    </#if>
    
    <#-- Handle LOB types -->
    <#if field.isLob>
    @Lob
    </#if>
    @Column(${columnParams?join(", ")})
    <#-- Handle default values by type -->
    <#if field.defaultValue??>
    @Builder.Default
    private ${field.javaType} ${field.name} = <#rt>
        <#if field.javaType == "String">"${field.defaultValue}"<#t>
        <#elseif field.javaType == "Boolean">${field.defaultValue?lower_case}<#t>
        <#elseif field.javaType == "Integer" || field.javaType == "Long">${field.defaultValue}<#t>
        <#elseif field.javaType == "BigDecimal">new BigDecimal("${field.defaultValue}")<#t>
        <#elseif field.javaType == "Double">${field.defaultValue}D<#t>
        <#elseif field.javaType == "Float">${field.defaultValue}F<#t>
        <#elseif field.javaType == "LocalDate">LocalDate.parse("${field.defaultValue}")<#t>
        <#elseif field.javaType == "LocalDateTime">LocalDateTime.parse("${field.defaultValue}")<#t>
        <#else>${field.defaultValue}<#t>
        </#if>;
    <#else>
    private ${field.javaType} ${field.name};
    </#if>
    </#if>
</#list><#t>

<#-- ========================================== -->
<#-- STEP 4: JPA RELATIONS -->
<#-- ========================================== -->
<#list entity.relations as rel>
    <#assign relType = rel.type?string>
    
    <#-- MANY_TO_ONE relation -->
    <#if relType == "MANY_TO_ONE">
    /**
     * ${relType} relation towards ${rel.targetEntityClass}
     * <#if rel.joinColumns?has_content>FK: ${rel.joinColumns?join(", ")}</#if>
     */
    @ManyToOne<#assign params = []><#if rel.fetchType??><#assign params += ["fetch = FetchType." + rel.fetchType?string]></#if><#if rel.cascadeType??><#assign params += ["cascade = {CascadeType.PERSIST, CascadeType.MERGE}"]><#else><#assign params += ["cascade = {CascadeType.PERSIST, CascadeType.MERGE}"]></#if><#if rel.optional?? && rel.optional?is_boolean><#assign params += ["optional = " + rel.optional?c]></#if><#if params?size != 0>(${params?join(", ")})</#if>
    <#if rel.joinColumns?size == 1>
    @JoinColumn(name = "${rel.joinColumns[0]}", referencedColumnName = "${rel.referencedColumns[0]}"<#if rel.optional?? && rel.optional?is_boolean && !rel.optional>, nullable = false</#if><#if entity.hasCompositeKey>, insertable = false, updatable = false</#if>)
    <#elseif rel.joinColumns?size &gt; 1>
    @JoinColumns({
        <#list 0..(rel.joinColumns?size - 1) as i>
        @JoinColumn(name = "${rel.joinColumns[i]}", referencedColumnName = "${rel.referencedColumns[i]}"<#if entity.hasCompositeKey>, insertable = false, updatable = false</#if>)<#if i + 1 < rel.joinColumns?size>,</#if>
        </#list>
    })
    </#if>
    private ${rel.targetEntityClass} ${rel.fieldName};
    </#if><#t>

    <#-- ONE_TO_ONE relation -->
    <#if relType == "ONE_TO_ONE">
    /**
     * ${relType} relation towards ${rel.targetEntityClass}
     * <#if rel.mappedBy??>Mapped by: ${rel.mappedBy}<#else>Owning side</#if>
     */
    @OneToOne<#assign params = []><#if rel.fetchType??><#assign params += ["fetch = FetchType." + rel.fetchType?string]></#if><#if rel.cascadeType??><#assign params += ["cascade = CascadeType." + rel.cascadeType?string]></#if><#if rel.mappedBy??><#assign params += ["mappedBy = \"" + rel.mappedBy + "\""]></#if><#if rel.optional?? && rel.optional?is_boolean && !rel.mappedBy??><#assign params += ["optional = " + rel.optional?c]></#if><#if rel.orphanRemoval?? && rel.orphanRemoval?is_boolean && rel.orphanRemoval><#assign params += ["orphanRemoval = true"]></#if><#if params?size != 0>(${params?join(", ")})</#if>
    <#if rel.mapsId??>
    @MapsId<#if rel.mapsId?has_content>("${rel.mapsId}")</#if>
    </#if>
    <#if !rel.mappedBy?? && rel.joinColumns?size == 1>
    @JoinColumn(name = "${rel.joinColumns[0]}", referencedColumnName = "${rel.referencedColumns[0]}"<#if rel.optional?? && rel.optional?is_boolean && !rel.optional>, nullable = false</#if><#if entity.hasCompositeKey>, insertable = false, updatable = false</#if>)
    <#elseif !rel.mappedBy?? && rel.joinColumns?size &gt; 1>
    @JoinColumns({
        <#list 0..(rel.joinColumns?size - 1) as i>
        @JoinColumn(name = "${rel.joinColumns[i]}", referencedColumnName = "${rel.referencedColumns[i]}"<#if entity.hasCompositeKey>, insertable = false, updatable = false</#if>)<#if i + 1 < rel.joinColumns?size>,</#if>
        </#list>
    })
    </#if>
    private ${rel.targetEntityClass} ${rel.fieldName};
    </#if><#t>

    <#-- ONE_TO_MANY relation -->
    <#if relType == "ONE_TO_MANY">
    /**
     * ${relType} relation towards ${rel.targetEntityClass}
     * Mapped by: ${rel.mappedBy!"N/A"}
     */
    @OneToMany<#assign params = []><#if rel.mappedBy??><#assign params += ["mappedBy = \"" + rel.mappedBy + "\""]></#if><#if rel.fetchType??><#assign params += ["fetch = FetchType." + rel.fetchType?string]></#if><#if rel.cascadeType??><#assign params += ["cascade = CascadeType." + rel.cascadeType?string]></#if><#if rel.orphanRemoval?? && rel.orphanRemoval?is_boolean && rel.orphanRemoval><#assign params += ["orphanRemoval = true"]></#if><#if params?size != 0>(${params?join(", ")})</#if>
    <#assign collectionType = (rel.collectionType?string)!"LIST">
    <#if collectionType == "SET">
    @Builder.Default
    private Set<${rel.targetEntityClass}> ${rel.fieldName} = new LinkedHashSet<>();
    <#else>
    @Builder.Default
    private List<${rel.targetEntityClass}> ${rel.fieldName} = new ArrayList<>();
    </#if>
    </#if><#t>

    <#-- MANY_TO_MANY relation -->
    <#if relType == "MANY_TO_MANY">
    /**
     * ${relType} relation towards ${rel.targetEntityClass}
     * <#if rel.joinTableName??>Join Table: ${rel.joinTableName}</#if>
     * <#if rel.mappedBy??>Mapped by: ${rel.mappedBy}<#else>Owning side</#if>
     */
    @ManyToMany<#assign params = []><#if rel.fetchType??><#assign params += ["fetch = FetchType." + rel.fetchType?string]></#if><#if rel.cascadeType??><#assign params += ["cascade = {CascadeType.PERSIST, CascadeType.MERGE}"]><#else><#assign params += ["cascade = {CascadeType.PERSIST, CascadeType.MERGE}"]></#if><#if rel.mappedBy??><#assign params += ["mappedBy = \"" + rel.mappedBy + "\""]></#if><#if params?size != 0>(${params?join(", ")})</#if>
    <#if !rel.mappedBy?? && rel.joinTableName??>
    @JoinTable(
        name = "${rel.joinTableName}",
        joinColumns = <#if rel.joinColumns?size == 1>@JoinColumn(name = "${rel.joinColumns[0]}", referencedColumnName = "${rel.referencedColumns[0]}")<#else>{
            <#list 0..(rel.joinColumns?size - 1) as i>
            @JoinColumn(name = "${rel.joinColumns[i]}", referencedColumnName = "${rel.referencedColumns[i]}")<#if i + 1 < rel.joinColumns?size>, </#if>
            </#list>
        }</#if>,
        inverseJoinColumns = <#if rel.inverseJoinColumns?size == 1>@JoinColumn(name = "${rel.inverseJoinColumns[0]}", referencedColumnName = "${rel.inverseReferencedColumns[0]}")<#else>{
            <#list 0..(rel.inverseJoinColumns?size - 1) as i>
            @JoinColumn(name = "${rel.inverseJoinColumns[i]}", referencedColumnName = "${rel.inverseReferencedColumns[i]}")<#if i + 1 < rel.inverseJoinColumns?size>, </#if>
            </#list>
        }</#if>
    )
    </#if>
    <#assign collectionType = (rel.collectionType?string)!"LIST">
    <#if collectionType == "SET">
    @Builder.Default
    private Set<${rel.targetEntityClass}> ${rel.fieldName} = new LinkedHashSet<>();
    <#else>
    @Builder.Default
    private List<${rel.targetEntityClass}> ${rel.fieldName} = new ArrayList<>();
    </#if>
    </#if>

    <#-- MANY_TO_MANY_DIRECT relation - Direct @ManyToMany without association entity -->
    <#if relType == "MANY_TO_MANY_DIRECT">
    /**
     * ${relType} direct relation towards ${rel.targetEntityClass} (bypassing association entity)
     * <#if rel.joinTableName??>Join Table: ${rel.joinTableName}</#if>
     * <#if rel.mappedBy??>Mapped by: ${rel.mappedBy}<#else>Owning side</#if>
     */
    @ManyToMany<#assign params = []><#if rel.fetchType??><#assign params += ["fetch = FetchType." + rel.fetchType?string]></#if><#assign params += ["cascade = {CascadeType.PERSIST, CascadeType.MERGE}"]><#if rel.mappedBy??><#assign params += ["mappedBy = \"" + rel.mappedBy + "\""]></#if><#if params?size != 0>(${params?join(", ")})</#if>
    <#if !rel.mappedBy?? && rel.joinTableName??>
    @JoinTable(
        name = "${rel.joinTableName}",
        joinColumns = <#if rel.joinColumns?size == 1>@JoinColumn(name = "${rel.joinColumns[0]}", referencedColumnName = "${rel.referencedColumns[0]}")<#else>{
            <#list 0..(rel.joinColumns?size - 1) as i>
            @JoinColumn(name = "${rel.joinColumns[i]}", referencedColumnName = "${rel.referencedColumns[i]}")<#if i + 1 < rel.joinColumns?size>, </#if>
            </#list>
        }</#if>,
        inverseJoinColumns = <#if rel.inverseJoinColumns?size == 1>@JoinColumn(name = "${rel.inverseJoinColumns[0]}", referencedColumnName = "${rel.inverseReferencedColumns[0]}")<#else>{
            <#list 0..(rel.inverseJoinColumns?size - 1) as i>
            @JoinColumn(name = "${rel.inverseJoinColumns[i]}", referencedColumnName = "${rel.inverseReferencedColumns[i]}")<#if i + 1 < rel.inverseJoinColumns?size>, </#if>
            </#list>
        }</#if>
    )
    </#if>
    @Builder.Default
    private Set<${rel.targetEntityClass}> ${rel.fieldName} = new LinkedHashSet<>();
    </#if>
</#list>

<#-- ========================================== -->
<#-- STEP 5: SELF-REFERENCING COLLECTION -->
<#-- ========================================== -->
<#list entity.relations as rel>
    <#if rel.selfReferencing && rel.type?string == "ONE_TO_MANY" && rel.mappedBy??>
    /**
     * Self-referencing ONE_TO_MANY collection - child entities
     * Mapped by: ${rel.mappedBy}
     */
    @OneToMany(mappedBy = "${rel.mappedBy}", fetch = FetchType.LAZY, cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @Builder.Default
    private List<${rel.targetEntityClass}> ${rel.fieldName} = new ArrayList<>();
    </#if>
</#list>
}
